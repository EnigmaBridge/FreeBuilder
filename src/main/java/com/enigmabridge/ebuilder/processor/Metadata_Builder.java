// Autogenerated code. Do not modify.
package com.enigmabridge.ebuilder.processor;

import com.enigmabridge.ebuilder.processor.util.Excerpt;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Function;
import com.google.common.base.Joiner;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.enigmabridge.ebuilder.processor.util.ParameterizedType;
import com.enigmabridge.ebuilder.processor.util.QualifiedName;

import javax.annotation.Generated;
import javax.annotation.Nullable;
import java.util.*;

/**
 * Auto-generated superclass of {@link Metadata.Builder},
 * derived from the API of {@link Metadata}.
 */
@Generated("CodeGenerator")
abstract class Metadata_Builder {

  /**
   * Creates a new builder using {@code value} as a template.
   */
  public static Metadata.Builder from(Metadata value) {
    return new Metadata.Builder().mergeFrom(value);
  }

  private static final Joiner COMMA_JOINER = Joiner.on(", ").skipNulls();

  private enum Property {
    TYPE("type"),
    TYPE_GEN("typeGen"),
    BUILD_GEN("buildGen"),
    INTERFACE_TYPE("interfaceType"),
    GENERATED_A_BUILDER("generatedABuilder"),
    GENERATED_A_BUILDER_PARAMETRIZED("generatedABuilderParametrized"),
    GENERATED_A_BUILDER_PARAMETRIZED_SPEC("generatedABuilderParametrizedSpec"),
    GENERATED_BUILDER("generatedBuilder"),
    VALUE_TYPE("valueType"),
    PARTIAL_TYPE("partialType"),
    PROPERTY_ENUM("propertyEnum"),
    BUILDER_SERIALIZABLE("builderSerializable"),
    VALUE_TYPE_VISIBILITY("valueTypeVisibility"),
    ;

    private final String name;

    private Property(String name) {
      this.name = name;
    }

    @Override
    public String toString() {
      return name;
    }
  }

  private ParameterizedType type;
  private String typeGen;
  private String buildGen;
  private boolean interfaceType;
  // Store a nullable object instead of an Optional. Escape analysis then
  // allows the JVM to optimize away the Optional objects created by and
  // passed to our API.
  private ParameterizedType optionalBuilder = null;
  // Store a nullable object instead of an Optional. Escape analysis then
  // allows the JVM to optimize away the Optional objects created by and
  // passed to our API.
  private ParameterizedType optionalABuilder = null;
  // Store a nullable object instead of an Optional. Escape analysis then
  // allows the JVM to optimize away the Optional objects created by and
  // passed to our API.
  private ParameterizedType optionalABuilderAncestor = null;
  // Store a nullable object instead of an Optional. Escape analysis then
  // allows the JVM to optimize away the Optional objects created by and
  // passed to our API.
  private ParameterizedType optionalABuilderExtension = null;
  // Store a nullable object instead of an Optional. Escape analysis then
  // allows the JVM to optimize away the Optional objects created by and
  // passed to our API.
  private BuilderFactory builderFactory = null;
  private ParameterizedType generatedABuilder;
  private ParameterizedType generatedABuilderParametrized;
  private ParameterizedType generatedABuilderParametrizedSpec;
  private ParameterizedType generatedBuilder;
  private ParameterizedType valueType;
  private ParameterizedType partialType;
  private Set<QualifiedName> visibleNestedTypes = ImmutableSet.of();
  private ParameterizedType propertyEnum;
  private List<Metadata.Property> properties = ImmutableList.of();
  private List<Metadata.Property> ownProperties = ImmutableList.of();
  private Set<ParameterizedType> superBuilderTypes = ImmutableSet.of();
  private final LinkedHashMap<ParameterizedType, ImmutableList<Metadata.Property>>
      superTypeProperties =
          new LinkedHashMap<ParameterizedType, ImmutableList<Metadata.Property>>();
  private final LinkedHashMap<Metadata.StandardMethod, Metadata.UnderrideLevel>
      standardMethodUnderrides =
          new LinkedHashMap<Metadata.StandardMethod, Metadata.UnderrideLevel>();
  private boolean builderSerializable;
  private List<Excerpt> generatedBuilderAnnotations = ImmutableList.of();
  private List<Excerpt> valueTypeAnnotations = ImmutableList.of();
  private Metadata.Visibility valueTypeVisibility;
  private List<Function<Metadata, Excerpt>> nestedClasses =
      ImmutableList.of();
  private final EnumSet<Property> _unsetProperties =
      EnumSet.allOf(Metadata_Builder.Property.class);

  /**
   * Sets the value to be returned by {@link Metadata#getType()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code type} is null
   */
  public Metadata.Builder setType(ParameterizedType type) {
    this.type = Preconditions.checkNotNull(type);
    _unsetProperties.remove(Metadata_Builder.Property.TYPE);
    return (Metadata.Builder) this;
  }

  /**
   * Returns the value that will be returned by {@link Metadata#getType()}.
   *
   * @throws IllegalStateException if the field has not been set
   */
  public ParameterizedType getType() {
    Preconditions.checkState(
        !_unsetProperties.contains(Metadata_Builder.Property.TYPE), "type not set");
    return type;
  }

  /**
   * Sets the value to be returned by {@link Metadata#getTypeGen()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code typeGen} is null
   */
  public Metadata.Builder setTypeGen(String typeGen) {
    this.typeGen = Preconditions.checkNotNull(typeGen);
    _unsetProperties.remove(Metadata_Builder.Property.TYPE_GEN);
    return (Metadata.Builder) this;
  }

  /**
   * Returns the value that will be returned by {@link Metadata#getTypeGen()}.
   *
   * @throws IllegalStateException if the field has not been set
   */
  public String getTypeGen() {
    Preconditions.checkState(
        !_unsetProperties.contains(Metadata_Builder.Property.TYPE_GEN), "typeGen not set");
    return typeGen;
  }

  /**
   * Sets the value to be returned by {@link Metadata#getBuildGen()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code buildGen} is null
   */
  public Metadata.Builder setBuildGen(String buildGen) {
    this.buildGen = Preconditions.checkNotNull(buildGen);
    _unsetProperties.remove(Metadata_Builder.Property.BUILD_GEN);
    return (Metadata.Builder) this;
  }

  /**
   * Returns the value that will be returned by {@link Metadata#getBuildGen()}.
   *
   * @throws IllegalStateException if the field has not been set
   */
  public String getBuildGen() {
    Preconditions.checkState(
        !_unsetProperties.contains(Metadata_Builder.Property.BUILD_GEN), "buildGen not set");
    return buildGen;
  }

  /**
   * Sets the value to be returned by {@link Metadata#isInterfaceType()}.
   *
   * @return this {@code Builder} object
   */
  public Metadata.Builder setInterfaceType(boolean interfaceType) {
    this.interfaceType = interfaceType;
    _unsetProperties.remove(Metadata_Builder.Property.INTERFACE_TYPE);
    return (Metadata.Builder) this;
  }

  /**
   * Returns the value that will be returned by {@link Metadata#isInterfaceType()}.
   *
   * @throws IllegalStateException if the field has not been set
   */
  public boolean isInterfaceType() {
    Preconditions.checkState(
        !_unsetProperties.contains(Metadata_Builder.Property.INTERFACE_TYPE),
        "interfaceType not set");
    return interfaceType;
  }

  /**
   * Sets the value to be returned by {@link Metadata#getOptionalBuilder()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code optionalBuilder} is null
   */
  public Metadata.Builder setOptionalBuilder(ParameterizedType optionalBuilder) {
    this.optionalBuilder = Preconditions.checkNotNull(optionalBuilder);
    return (Metadata.Builder) this;
  }

  /**
   * Sets the value to be returned by {@link Metadata#getOptionalBuilder()}.
   *
   * @return this {@code Builder} object
   */
  public Metadata.Builder setOptionalBuilder(
      Optional<? extends ParameterizedType> optionalBuilder) {
    if (optionalBuilder.isPresent()) {
      return setOptionalBuilder(optionalBuilder.get());
    } else {
      return clearOptionalBuilder();
    }
  }

  /**
   * Sets the value to be returned by {@link Metadata#getOptionalBuilder()}.
   *
   * @return this {@code Builder} object
   */
  public Metadata.Builder setNullableOptionalBuilder(@Nullable ParameterizedType optionalBuilder) {
    if (optionalBuilder != null) {
      return setOptionalBuilder(optionalBuilder);
    } else {
      return clearOptionalBuilder();
    }
  }

  /**
   * Sets the value to be returned by {@link Metadata#getOptionalBuilder()}
   * to {@link Optional#absent() Optional.absent()}.
   *
   * @return this {@code Builder} object
   */
  public Metadata.Builder clearOptionalBuilder() {
    this.optionalBuilder = null;
    return (Metadata.Builder) this;
  }

  /**
   * Returns the value that will be returned by {@link Metadata#getOptionalBuilder()}.
   */
  public Optional<ParameterizedType> getOptionalBuilder() {
    return Optional.fromNullable(optionalBuilder);
  }

  /**
   * Sets the value to be returned by {@link Metadata#getOptionalABuilder()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code optionalABuilder} is null
   */
  public Metadata.Builder setOptionalABuilder(ParameterizedType optionalABuilder) {
    this.optionalABuilder = Preconditions.checkNotNull(optionalABuilder);
    return (Metadata.Builder) this;
  }

  /**
   * Sets the value to be returned by {@link Metadata#getOptionalABuilder()}.
   *
   * @return this {@code Builder} object
   */
  public Metadata.Builder setOptionalABuilder(
      Optional<? extends ParameterizedType> optionalABuilder) {
    if (optionalABuilder.isPresent()) {
      return setOptionalABuilder(optionalABuilder.get());
    } else {
      return clearOptionalABuilder();
    }
  }

  /**
   * Sets the value to be returned by {@link Metadata#getOptionalABuilder()}.
   *
   * @return this {@code Builder} object
   */
  public Metadata.Builder setNullableOptionalABuilder(
      @Nullable ParameterizedType optionalABuilder) {
    if (optionalABuilder != null) {
      return setOptionalABuilder(optionalABuilder);
    } else {
      return clearOptionalABuilder();
    }
  }

  /**
   * Sets the value to be returned by {@link Metadata#getOptionalABuilder()}
   * to {@link Optional#absent() Optional.absent()}.
   *
   * @return this {@code Builder} object
   */
  public Metadata.Builder clearOptionalABuilder() {
    this.optionalABuilder = null;
    return (Metadata.Builder) this;
  }

  /**
   * Returns the value that will be returned by {@link Metadata#getOptionalABuilder()}.
   */
  public Optional<ParameterizedType> getOptionalABuilder() {
    return Optional.fromNullable(optionalABuilder);
  }

  /**
   * Sets the value to be returned by {@link Metadata#getOptionalABuilderAncestor()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code optionalABuilderAncestor} is null
   */
  public Metadata.Builder setOptionalABuilderAncestor(ParameterizedType optionalABuilderAncestor) {
    this.optionalABuilderAncestor = Preconditions.checkNotNull(optionalABuilderAncestor);
    return (Metadata.Builder) this;
  }

  /**
   * Sets the value to be returned by {@link Metadata#getOptionalABuilderAncestor()}.
   *
   * @return this {@code Builder} object
   */
  public Metadata.Builder setOptionalABuilderAncestor(
      Optional<? extends ParameterizedType> optionalABuilderAncestor) {
    if (optionalABuilderAncestor.isPresent()) {
      return setOptionalABuilderAncestor(optionalABuilderAncestor.get());
    } else {
      return clearOptionalABuilderAncestor();
    }
  }

  /**
   * Sets the value to be returned by {@link Metadata#getOptionalABuilderAncestor()}.
   *
   * @return this {@code Builder} object
   */
  public Metadata.Builder setNullableOptionalABuilderAncestor(
      @Nullable ParameterizedType optionalABuilderAncestor) {
    if (optionalABuilderAncestor != null) {
      return setOptionalABuilderAncestor(optionalABuilderAncestor);
    } else {
      return clearOptionalABuilderAncestor();
    }
  }

  /**
   * Sets the value to be returned by {@link Metadata#getOptionalABuilderAncestor()}
   * to {@link Optional#absent() Optional.absent()}.
   *
   * @return this {@code Builder} object
   */
  public Metadata.Builder clearOptionalABuilderAncestor() {
    this.optionalABuilderAncestor = null;
    return (Metadata.Builder) this;
  }

  /**
   * Returns the value that will be returned by {@link Metadata#getOptionalABuilderAncestor()}.
   */
  public Optional<ParameterizedType> getOptionalABuilderAncestor() {
    return Optional.fromNullable(optionalABuilderAncestor);
  }

  /**
   * Sets the value to be returned by {@link Metadata#getOptionalABuilderExtension()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code optionalABuilderExtension} is null
   */
  public Metadata.Builder setOptionalABuilderExtension(
      ParameterizedType optionalABuilderExtension) {
    this.optionalABuilderExtension = Preconditions.checkNotNull(optionalABuilderExtension);
    return (Metadata.Builder) this;
  }

  /**
   * Sets the value to be returned by {@link Metadata#getOptionalABuilderExtension()}.
   *
   * @return this {@code Builder} object
   */
  public Metadata.Builder setOptionalABuilderExtension(
      Optional<? extends ParameterizedType> optionalABuilderExtension) {
    if (optionalABuilderExtension.isPresent()) {
      return setOptionalABuilderExtension(optionalABuilderExtension.get());
    } else {
      return clearOptionalABuilderExtension();
    }
  }

  /**
   * Sets the value to be returned by {@link Metadata#getOptionalABuilderExtension()}.
   *
   * @return this {@code Builder} object
   */
  public Metadata.Builder setNullableOptionalABuilderExtension(
      @Nullable ParameterizedType optionalABuilderExtension) {
    if (optionalABuilderExtension != null) {
      return setOptionalABuilderExtension(optionalABuilderExtension);
    } else {
      return clearOptionalABuilderExtension();
    }
  }

  /**
   * Sets the value to be returned by {@link Metadata#getOptionalABuilderExtension()}
   * to {@link Optional#absent() Optional.absent()}.
   *
   * @return this {@code Builder} object
   */
  public Metadata.Builder clearOptionalABuilderExtension() {
    this.optionalABuilderExtension = null;
    return (Metadata.Builder) this;
  }

  /**
   * Returns the value that will be returned by {@link Metadata#getOptionalABuilderExtension()}.
   */
  public Optional<ParameterizedType> getOptionalABuilderExtension() {
    return Optional.fromNullable(optionalABuilderExtension);
  }

  /**
   * Sets the value to be returned by {@link Metadata#getBuilderFactory()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code builderFactory} is null
   */
  public Metadata.Builder setBuilderFactory(BuilderFactory builderFactory) {
    this.builderFactory = Preconditions.checkNotNull(builderFactory);
    return (Metadata.Builder) this;
  }

  /**
   * Sets the value to be returned by {@link Metadata#getBuilderFactory()}.
   *
   * @return this {@code Builder} object
   */
  public Metadata.Builder setBuilderFactory(Optional<? extends BuilderFactory> builderFactory) {
    if (builderFactory.isPresent()) {
      return setBuilderFactory(builderFactory.get());
    } else {
      return clearBuilderFactory();
    }
  }

  /**
   * Sets the value to be returned by {@link Metadata#getBuilderFactory()}.
   *
   * @return this {@code Builder} object
   */
  public Metadata.Builder setNullableBuilderFactory(@Nullable BuilderFactory builderFactory) {
    if (builderFactory != null) {
      return setBuilderFactory(builderFactory);
    } else {
      return clearBuilderFactory();
    }
  }

  /**
   * Sets the value to be returned by {@link Metadata#getBuilderFactory()}
   * to {@link Optional#absent() Optional.absent()}.
   *
   * @return this {@code Builder} object
   */
  public Metadata.Builder clearBuilderFactory() {
    this.builderFactory = null;
    return (Metadata.Builder) this;
  }

  /**
   * Returns the value that will be returned by {@link Metadata#getBuilderFactory()}.
   */
  public Optional<BuilderFactory> getBuilderFactory() {
    return Optional.fromNullable(builderFactory);
  }

  /**
   * Sets the value to be returned by {@link Metadata#getGeneratedABuilder()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code generatedABuilder} is null
   */
  public Metadata.Builder setGeneratedABuilder(ParameterizedType generatedABuilder) {
    this.generatedABuilder = Preconditions.checkNotNull(generatedABuilder);
    _unsetProperties.remove(Metadata_Builder.Property.GENERATED_A_BUILDER);
    return (Metadata.Builder) this;
  }

  /**
   * Returns the value that will be returned by {@link Metadata#getGeneratedABuilder()}.
   *
   * @throws IllegalStateException if the field has not been set
   */
  public ParameterizedType getGeneratedABuilder() {
    Preconditions.checkState(
        !_unsetProperties.contains(Metadata_Builder.Property.GENERATED_A_BUILDER),
        "generatedABuilder not set");
    return generatedABuilder;
  }

  /**
   * Sets the value to be returned by {@link Metadata#getGeneratedABuilderParametrized()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code generatedABuilderParametrized} is null
   */
  public Metadata.Builder setGeneratedABuilderParametrized(
      ParameterizedType generatedABuilderParametrized) {
    this.generatedABuilderParametrized = Preconditions.checkNotNull(generatedABuilderParametrized);
    _unsetProperties.remove(Metadata_Builder.Property.GENERATED_A_BUILDER_PARAMETRIZED);
    return (Metadata.Builder) this;
  }

  /**
   * Returns the value that will be returned by {@link Metadata#getGeneratedABuilderParametrized()}.
   *
   * @throws IllegalStateException if the field has not been set
   */
  public ParameterizedType getGeneratedABuilderParametrized() {
    Preconditions.checkState(
        !_unsetProperties.contains(Metadata_Builder.Property.GENERATED_A_BUILDER_PARAMETRIZED),
        "generatedABuilderParametrized not set");
    return generatedABuilderParametrized;
  }

  /**
   * Sets the value to be returned by {@link Metadata#getGeneratedABuilderParametrizedSpec()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code generatedABuilderParametrizedSpec} is null
   */
  public Metadata.Builder setGeneratedABuilderParametrizedSpec(
      ParameterizedType generatedABuilderParametrizedSpec) {
    this.generatedABuilderParametrizedSpec =
        Preconditions.checkNotNull(generatedABuilderParametrizedSpec);
    _unsetProperties.remove(Metadata_Builder.Property.GENERATED_A_BUILDER_PARAMETRIZED_SPEC);
    return (Metadata.Builder) this;
  }

  /**
   * Returns the value that will be returned by {@link Metadata#getGeneratedABuilderParametrizedSpec()}.
   *
   * @throws IllegalStateException if the field has not been set
   */
  public ParameterizedType getGeneratedABuilderParametrizedSpec() {
    Preconditions.checkState(
        !_unsetProperties.contains(Metadata_Builder.Property.GENERATED_A_BUILDER_PARAMETRIZED_SPEC),
        "generatedABuilderParametrizedSpec not set");
    return generatedABuilderParametrizedSpec;
  }

  /**
   * Sets the value to be returned by {@link Metadata#getGeneratedBuilder()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code generatedBuilder} is null
   */
  public Metadata.Builder setGeneratedBuilder(ParameterizedType generatedBuilder) {
    this.generatedBuilder = Preconditions.checkNotNull(generatedBuilder);
    _unsetProperties.remove(Metadata_Builder.Property.GENERATED_BUILDER);
    return (Metadata.Builder) this;
  }

  /**
   * Returns the value that will be returned by {@link Metadata#getGeneratedBuilder()}.
   *
   * @throws IllegalStateException if the field has not been set
   */
  public ParameterizedType getGeneratedBuilder() {
    Preconditions.checkState(
        !_unsetProperties.contains(Metadata_Builder.Property.GENERATED_BUILDER),
        "generatedBuilder not set");
    return generatedBuilder;
  }

  /**
   * Sets the value to be returned by {@link Metadata#getValueType()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code valueType} is null
   */
  public Metadata.Builder setValueType(ParameterizedType valueType) {
    this.valueType = Preconditions.checkNotNull(valueType);
    _unsetProperties.remove(Metadata_Builder.Property.VALUE_TYPE);
    return (Metadata.Builder) this;
  }

  /**
   * Returns the value that will be returned by {@link Metadata#getValueType()}.
   *
   * @throws IllegalStateException if the field has not been set
   */
  public ParameterizedType getValueType() {
    Preconditions.checkState(
        !_unsetProperties.contains(Metadata_Builder.Property.VALUE_TYPE), "valueType not set");
    return valueType;
  }

  /**
   * Sets the value to be returned by {@link Metadata#getPartialType()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code partialType} is null
   */
  public Metadata.Builder setPartialType(ParameterizedType partialType) {
    this.partialType = Preconditions.checkNotNull(partialType);
    _unsetProperties.remove(Metadata_Builder.Property.PARTIAL_TYPE);
    return (Metadata.Builder) this;
  }

  /**
   * Returns the value that will be returned by {@link Metadata#getPartialType()}.
   *
   * @throws IllegalStateException if the field has not been set
   */
  public ParameterizedType getPartialType() {
    Preconditions.checkState(
        !_unsetProperties.contains(Metadata_Builder.Property.PARTIAL_TYPE), "partialType not set");
    return partialType;
  }

  /**
   * Adds {@code element} to the set to be returned from {@link Metadata#getVisibleNestedTypes()}.
   * If the set already contains {@code element}, then {@code addVisibleNestedTypes}
   * has no effect (only the previously added element is retained).
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code element} is null
   */
  public Metadata.Builder addVisibleNestedTypes(QualifiedName element) {
    if (this.visibleNestedTypes instanceof ImmutableSet) {
      this.visibleNestedTypes = new LinkedHashSet<QualifiedName>(this.visibleNestedTypes);
    }
    this.visibleNestedTypes.add(Preconditions.checkNotNull(element));
    return (Metadata.Builder) this;
  }

  /**
   * Adds each element of {@code elements} to the set to be returned from
   * {@link Metadata#getVisibleNestedTypes()}, ignoring duplicate elements
   * (only the first duplicate element is added).
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code elements} is null or contains a
   *     null element
   */
  public Metadata.Builder addVisibleNestedTypes(QualifiedName... elements) {
    return addAllVisibleNestedTypes(Arrays.asList(elements));
  }

  /**
   * Adds each element of {@code elements} to the set to be returned from
   * {@link Metadata#getVisibleNestedTypes()}, ignoring duplicate elements
   * (only the first duplicate element is added).
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code elements} is null or contains a
   *     null element
   */
  public Metadata.Builder addAllVisibleNestedTypes(Iterable<? extends QualifiedName> elements) {
    for (QualifiedName element : elements) {
      addVisibleNestedTypes(element);
    }
    return (Metadata.Builder) this;
  }

  /**
   * Removes {@code element} from the set to be returned from {@link Metadata#getVisibleNestedTypes()}.
   * Does nothing if {@code element} is not a member of the set.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code element} is null
   */
  public Metadata.Builder removeVisibleNestedTypes(QualifiedName element) {
    if (this.visibleNestedTypes instanceof ImmutableSet) {
      this.visibleNestedTypes = new LinkedHashSet<QualifiedName>(this.visibleNestedTypes);
    }
    this.visibleNestedTypes.remove(Preconditions.checkNotNull(element));
    return (Metadata.Builder) this;
  }

  /**
   * Clears the set to be returned from {@link Metadata#getVisibleNestedTypes()}.
   *
   * @return this {@code Builder} object
   */
  public Metadata.Builder clearVisibleNestedTypes() {
    if (visibleNestedTypes instanceof ImmutableSet) {
      visibleNestedTypes = ImmutableSet.of();
    } else {
      visibleNestedTypes.clear();
    }
    return (Metadata.Builder) this;
  }

  /**
   * Returns an unmodifiable view of the set that will be returned by
   * {@link Metadata#getVisibleNestedTypes()}.
   * Changes to this builder will be reflected in the view.
   */
  public Set<QualifiedName> getVisibleNestedTypes() {
    if (visibleNestedTypes instanceof ImmutableSet) {
      visibleNestedTypes = new LinkedHashSet<QualifiedName>(visibleNestedTypes);
    }
    return Collections.unmodifiableSet(visibleNestedTypes);
  }

  /**
   * Sets the value to be returned by {@link Metadata#getPropertyEnum()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code propertyEnum} is null
   */
  public Metadata.Builder setPropertyEnum(ParameterizedType propertyEnum) {
    this.propertyEnum = Preconditions.checkNotNull(propertyEnum);
    _unsetProperties.remove(Metadata_Builder.Property.PROPERTY_ENUM);
    return (Metadata.Builder) this;
  }

  /**
   * Returns the value that will be returned by {@link Metadata#getPropertyEnum()}.
   *
   * @throws IllegalStateException if the field has not been set
   */
  public ParameterizedType getPropertyEnum() {
    Preconditions.checkState(
        !_unsetProperties.contains(Metadata_Builder.Property.PROPERTY_ENUM),
        "propertyEnum not set");
    return propertyEnum;
  }

  /**
   * Adds {@code element} to the list to be returned from {@link Metadata#getProperties()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code element} is null
   */
  public Metadata.Builder addProperties(Metadata.Property element) {
    if (this.properties instanceof ImmutableList) {
      this.properties = new ArrayList<Metadata.Property>(this.properties);
    }
    this.properties.add(Preconditions.checkNotNull(element));
    return (Metadata.Builder) this;
  }

  /**
   * Adds each element of {@code elements} to the list to be returned from
   * {@link Metadata#getProperties()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code elements} is null or contains a
   *     null element
   */
  public Metadata.Builder addProperties(Metadata.Property... elements) {
    return addAllProperties(Arrays.asList(elements));
  }

  /**
   * Adds each element of {@code elements} to the list to be returned from
   * {@link Metadata#getProperties()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code elements} is null or contains a
   *     null element
   */
  public Metadata.Builder addAllProperties(Iterable<? extends Metadata.Property> elements) {
    if (elements instanceof Collection) {
      int elementsSize = ((Collection<?>) elements).size();
      if (elementsSize != 0) {
        if (properties instanceof ImmutableList) {
          properties = new ArrayList<Metadata.Property>(properties);
        }
        ((ArrayList<?>) properties).ensureCapacity(properties.size() + elementsSize);
      }
    }
    for (Metadata.Property element : elements) {
      addProperties(element);
    }
    return (Metadata.Builder) this;
  }

  /**
   * Clears the list to be returned from {@link Metadata#getProperties()}.
   *
   * @return this {@code Builder} object
   */
  public Metadata.Builder clearProperties() {
    if (properties instanceof ImmutableList) {
      properties = ImmutableList.of();
    } else {
      properties.clear();
    }
    return (Metadata.Builder) this;
  }

  /**
   * Returns an unmodifiable view of the list that will be returned by
   * {@link Metadata#getProperties()}.
   * Changes to this builder will be reflected in the view.
   */
  public List<Metadata.Property> getProperties() {
    if (properties instanceof ImmutableList) {
      properties = new ArrayList<Metadata.Property>(properties);
    }
    return Collections.unmodifiableList(properties);
  }

  /**
   * Adds {@code element} to the list to be returned from {@link Metadata#getOwnProperties()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code element} is null
   */
  public Metadata.Builder addOwnProperties(Metadata.Property element) {
    if (this.ownProperties instanceof ImmutableList) {
      this.ownProperties = new ArrayList<Metadata.Property>(this.ownProperties);
    }
    this.ownProperties.add(Preconditions.checkNotNull(element));
    return (Metadata.Builder) this;
  }

  /**
   * Adds each element of {@code elements} to the list to be returned from
   * {@link Metadata#getOwnProperties()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code elements} is null or contains a
   *     null element
   */
  public Metadata.Builder addOwnProperties(Metadata.Property... elements) {
    return addAllOwnProperties(Arrays.asList(elements));
  }

  /**
   * Adds each element of {@code elements} to the list to be returned from
   * {@link Metadata#getOwnProperties()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code elements} is null or contains a
   *     null element
   */
  public Metadata.Builder addAllOwnProperties(Iterable<? extends Metadata.Property> elements) {
    if (elements instanceof Collection) {
      int elementsSize = ((Collection<?>) elements).size();
      if (elementsSize != 0) {
        if (ownProperties instanceof ImmutableList) {
          ownProperties = new ArrayList<Metadata.Property>(ownProperties);
        }
        ((ArrayList<?>) ownProperties).ensureCapacity(ownProperties.size() + elementsSize);
      }
    }
    for (Metadata.Property element : elements) {
      addOwnProperties(element);
    }
    return (Metadata.Builder) this;
  }

  /**
   * Clears the list to be returned from {@link Metadata#getOwnProperties()}.
   *
   * @return this {@code Builder} object
   */
  public Metadata.Builder clearOwnProperties() {
    if (ownProperties instanceof ImmutableList) {
      ownProperties = ImmutableList.of();
    } else {
      ownProperties.clear();
    }
    return (Metadata.Builder) this;
  }

  /**
   * Returns an unmodifiable view of the list that will be returned by
   * {@link Metadata#getOwnProperties()}.
   * Changes to this builder will be reflected in the view.
   */
  public List<Metadata.Property> getOwnProperties() {
    if (ownProperties instanceof ImmutableList) {
      ownProperties = new ArrayList<Metadata.Property>(ownProperties);
    }
    return Collections.unmodifiableList(ownProperties);
  }

  /**
   * Adds {@code element} to the set to be returned from {@link Metadata#getSuperBuilderTypes()}.
   * If the set already contains {@code element}, then {@code addSuperBuilderTypes}
   * has no effect (only the previously added element is retained).
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code element} is null
   */
  public Metadata.Builder addSuperBuilderTypes(ParameterizedType element) {
    if (this.superBuilderTypes instanceof ImmutableSet) {
      this.superBuilderTypes = new LinkedHashSet<ParameterizedType>(this.superBuilderTypes);
    }
    this.superBuilderTypes.add(Preconditions.checkNotNull(element));
    return (Metadata.Builder) this;
  }

  /**
   * Adds each element of {@code elements} to the set to be returned from
   * {@link Metadata#getSuperBuilderTypes()}, ignoring duplicate elements
   * (only the first duplicate element is added).
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code elements} is null or contains a
   *     null element
   */
  public Metadata.Builder addSuperBuilderTypes(ParameterizedType... elements) {
    return addAllSuperBuilderTypes(Arrays.asList(elements));
  }

  /**
   * Adds each element of {@code elements} to the set to be returned from
   * {@link Metadata#getSuperBuilderTypes()}, ignoring duplicate elements
   * (only the first duplicate element is added).
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code elements} is null or contains a
   *     null element
   */
  public Metadata.Builder addAllSuperBuilderTypes(Iterable<? extends ParameterizedType> elements) {
    for (ParameterizedType element : elements) {
      addSuperBuilderTypes(element);
    }
    return (Metadata.Builder) this;
  }

  /**
   * Removes {@code element} from the set to be returned from {@link Metadata#getSuperBuilderTypes()}.
   * Does nothing if {@code element} is not a member of the set.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code element} is null
   */
  public Metadata.Builder removeSuperBuilderTypes(ParameterizedType element) {
    if (this.superBuilderTypes instanceof ImmutableSet) {
      this.superBuilderTypes = new LinkedHashSet<ParameterizedType>(this.superBuilderTypes);
    }
    this.superBuilderTypes.remove(Preconditions.checkNotNull(element));
    return (Metadata.Builder) this;
  }

  /**
   * Clears the set to be returned from {@link Metadata#getSuperBuilderTypes()}.
   *
   * @return this {@code Builder} object
   */
  public Metadata.Builder clearSuperBuilderTypes() {
    if (superBuilderTypes instanceof ImmutableSet) {
      superBuilderTypes = ImmutableSet.of();
    } else {
      superBuilderTypes.clear();
    }
    return (Metadata.Builder) this;
  }

  /**
   * Returns an unmodifiable view of the set that will be returned by
   * {@link Metadata#getSuperBuilderTypes()}.
   * Changes to this builder will be reflected in the view.
   */
  public Set<ParameterizedType> getSuperBuilderTypes() {
    if (superBuilderTypes instanceof ImmutableSet) {
      superBuilderTypes = new LinkedHashSet<ParameterizedType>(superBuilderTypes);
    }
    return Collections.unmodifiableSet(superBuilderTypes);
  }

  /**
   * Associates {@code key} with {@code value} in the map to be returned from
   * {@link Metadata#getSuperTypeProperties()}.
   * If the map previously contained a mapping for the key,
   * the old value is replaced by the specified value.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if either {@code key} or {@code value} are null
   */
  public Metadata.Builder putSuperTypeProperties(
          ParameterizedType key, ImmutableList<Metadata.Property> value) {
    Preconditions.checkNotNull(key);
    Preconditions.checkNotNull(value);
    superTypeProperties.put(key, value);
    return (Metadata.Builder) this;
  }

  /**
   * Copies all of the mappings from {@code map} to the map to be returned from
   * {@link Metadata#getSuperTypeProperties()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code map} is null or contains a
   *     null key or value
   */
  public Metadata.Builder putAllSuperTypeProperties(
      Map<? extends ParameterizedType, ? extends ImmutableList<Metadata.Property>> map) {
    for (Map.Entry<? extends ParameterizedType, ? extends ImmutableList<Metadata.Property>> entry :
        map.entrySet()) {
      putSuperTypeProperties(entry.getKey(), entry.getValue());
    }
    return (Metadata.Builder) this;
  }

  /**
   * Removes the mapping for {@code key} from the map to be returned from
   * {@link Metadata#getSuperTypeProperties()}, if one is present.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code key} is null
   */
  public Metadata.Builder removeSuperTypeProperties(ParameterizedType key) {
    Preconditions.checkNotNull(key);
    superTypeProperties.remove(key);
    return (Metadata.Builder) this;
  }

  /**
   * Removes all of the mappings from the map to be returned from
   * {@link Metadata#getSuperTypeProperties()}.
   *
   * @return this {@code Builder} object
   */
  public Metadata.Builder clearSuperTypeProperties() {
    superTypeProperties.clear();
    return (Metadata.Builder) this;
  }

  /**
   * Returns an unmodifiable view of the map that will be returned by
   * {@link Metadata#getSuperTypeProperties()}.
   * Changes to this builder will be reflected in the view.
   */
  public Map<ParameterizedType, ImmutableList<Metadata.Property>> getSuperTypeProperties() {
    return Collections.unmodifiableMap(superTypeProperties);
  }

  /**
   * Associates {@code key} with {@code value} in the map to be returned from
   * {@link Metadata#getStandardMethodUnderrides()}.
   * If the map previously contained a mapping for the key,
   * the old value is replaced by the specified value.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if either {@code key} or {@code value} are null
   */
  public Metadata.Builder putStandardMethodUnderrides(
      Metadata.StandardMethod key, Metadata.UnderrideLevel value) {
    Preconditions.checkNotNull(key);
    Preconditions.checkNotNull(value);
    standardMethodUnderrides.put(key, value);
    return (Metadata.Builder) this;
  }

  /**
   * Copies all of the mappings from {@code map} to the map to be returned from
   * {@link Metadata#getStandardMethodUnderrides()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code map} is null or contains a
   *     null key or value
   */
  public Metadata.Builder putAllStandardMethodUnderrides(
      Map<? extends Metadata.StandardMethod, ? extends Metadata.UnderrideLevel> map) {
    for (Map.Entry<? extends Metadata.StandardMethod, ? extends Metadata.UnderrideLevel> entry :
        map.entrySet()) {
      putStandardMethodUnderrides(entry.getKey(), entry.getValue());
    }
    return (Metadata.Builder) this;
  }

  /**
   * Removes the mapping for {@code key} from the map to be returned from
   * {@link Metadata#getStandardMethodUnderrides()}, if one is present.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code key} is null
   */
  public Metadata.Builder removeStandardMethodUnderrides(Metadata.StandardMethod key) {
    Preconditions.checkNotNull(key);
    standardMethodUnderrides.remove(key);
    return (Metadata.Builder) this;
  }

  /**
   * Removes all of the mappings from the map to be returned from
   * {@link Metadata#getStandardMethodUnderrides()}.
   *
   * @return this {@code Builder} object
   */
  public Metadata.Builder clearStandardMethodUnderrides() {
    standardMethodUnderrides.clear();
    return (Metadata.Builder) this;
  }

  /**
   * Returns an unmodifiable view of the map that will be returned by
   * {@link Metadata#getStandardMethodUnderrides()}.
   * Changes to this builder will be reflected in the view.
   */
  public Map<Metadata.StandardMethod, Metadata.UnderrideLevel> getStandardMethodUnderrides() {
    return Collections.unmodifiableMap(standardMethodUnderrides);
  }

  /**
   * Sets the value to be returned by {@link Metadata#isBuilderSerializable()}.
   *
   * @return this {@code Builder} object
   */
  public Metadata.Builder setBuilderSerializable(boolean builderSerializable) {
    this.builderSerializable = builderSerializable;
    _unsetProperties.remove(Metadata_Builder.Property.BUILDER_SERIALIZABLE);
    return (Metadata.Builder) this;
  }

  /**
   * Returns the value that will be returned by {@link Metadata#isBuilderSerializable()}.
   *
   * @throws IllegalStateException if the field has not been set
   */
  public boolean isBuilderSerializable() {
    Preconditions.checkState(
        !_unsetProperties.contains(Metadata_Builder.Property.BUILDER_SERIALIZABLE),
        "builderSerializable not set");
    return builderSerializable;
  }

  /**
   * Adds {@code element} to the list to be returned from {@link Metadata#getGeneratedBuilderAnnotations()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code element} is null
   */
  public Metadata.Builder addGeneratedBuilderAnnotations(Excerpt element) {
    if (this.generatedBuilderAnnotations instanceof ImmutableList) {
      this.generatedBuilderAnnotations = new ArrayList<Excerpt>(this.generatedBuilderAnnotations);
    }
    this.generatedBuilderAnnotations.add(Preconditions.checkNotNull(element));
    return (Metadata.Builder) this;
  }

  /**
   * Adds each element of {@code elements} to the list to be returned from
   * {@link Metadata#getGeneratedBuilderAnnotations()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code elements} is null or contains a
   *     null element
   */
  public Metadata.Builder addGeneratedBuilderAnnotations(Excerpt... elements) {
    return addAllGeneratedBuilderAnnotations(Arrays.asList(elements));
  }

  /**
   * Adds each element of {@code elements} to the list to be returned from
   * {@link Metadata#getGeneratedBuilderAnnotations()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code elements} is null or contains a
   *     null element
   */
  public Metadata.Builder addAllGeneratedBuilderAnnotations(Iterable<? extends Excerpt> elements) {
    if (elements instanceof Collection) {
      int elementsSize = ((Collection<?>) elements).size();
      if (elementsSize != 0) {
        if (generatedBuilderAnnotations instanceof ImmutableList) {
          generatedBuilderAnnotations = new ArrayList<Excerpt>(generatedBuilderAnnotations);
        }
        ((ArrayList<?>) generatedBuilderAnnotations)
            .ensureCapacity(generatedBuilderAnnotations.size() + elementsSize);
      }
    }
    for (Excerpt element : elements) {
      addGeneratedBuilderAnnotations(element);
    }
    return (Metadata.Builder) this;
  }

  /**
   * Clears the list to be returned from {@link Metadata#getGeneratedBuilderAnnotations()}.
   *
   * @return this {@code Builder} object
   */
  public Metadata.Builder clearGeneratedBuilderAnnotations() {
    if (generatedBuilderAnnotations instanceof ImmutableList) {
      generatedBuilderAnnotations = ImmutableList.of();
    } else {
      generatedBuilderAnnotations.clear();
    }
    return (Metadata.Builder) this;
  }

  /**
   * Returns an unmodifiable view of the list that will be returned by
   * {@link Metadata#getGeneratedBuilderAnnotations()}.
   * Changes to this builder will be reflected in the view.
   */
  public List<Excerpt> getGeneratedBuilderAnnotations() {
    if (generatedBuilderAnnotations instanceof ImmutableList) {
      generatedBuilderAnnotations = new ArrayList<Excerpt>(generatedBuilderAnnotations);
    }
    return Collections.unmodifiableList(generatedBuilderAnnotations);
  }

  /**
   * Adds {@code element} to the list to be returned from {@link Metadata#getValueTypeAnnotations()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code element} is null
   */
  public Metadata.Builder addValueTypeAnnotations(Excerpt element) {
    if (this.valueTypeAnnotations instanceof ImmutableList) {
      this.valueTypeAnnotations = new ArrayList<Excerpt>(this.valueTypeAnnotations);
    }
    this.valueTypeAnnotations.add(Preconditions.checkNotNull(element));
    return (Metadata.Builder) this;
  }

  /**
   * Adds each element of {@code elements} to the list to be returned from
   * {@link Metadata#getValueTypeAnnotations()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code elements} is null or contains a
   *     null element
   */
  public Metadata.Builder addValueTypeAnnotations(Excerpt... elements) {
    return addAllValueTypeAnnotations(Arrays.asList(elements));
  }

  /**
   * Adds each element of {@code elements} to the list to be returned from
   * {@link Metadata#getValueTypeAnnotations()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code elements} is null or contains a
   *     null element
   */
  public Metadata.Builder addAllValueTypeAnnotations(Iterable<? extends Excerpt> elements) {
    if (elements instanceof Collection) {
      int elementsSize = ((Collection<?>) elements).size();
      if (elementsSize != 0) {
        if (valueTypeAnnotations instanceof ImmutableList) {
          valueTypeAnnotations = new ArrayList<Excerpt>(valueTypeAnnotations);
        }
        ((ArrayList<?>) valueTypeAnnotations)
            .ensureCapacity(valueTypeAnnotations.size() + elementsSize);
      }
    }
    for (Excerpt element : elements) {
      addValueTypeAnnotations(element);
    }
    return (Metadata.Builder) this;
  }

  /**
   * Clears the list to be returned from {@link Metadata#getValueTypeAnnotations()}.
   *
   * @return this {@code Builder} object
   */
  public Metadata.Builder clearValueTypeAnnotations() {
    if (valueTypeAnnotations instanceof ImmutableList) {
      valueTypeAnnotations = ImmutableList.of();
    } else {
      valueTypeAnnotations.clear();
    }
    return (Metadata.Builder) this;
  }

  /**
   * Returns an unmodifiable view of the list that will be returned by
   * {@link Metadata#getValueTypeAnnotations()}.
   * Changes to this builder will be reflected in the view.
   */
  public List<Excerpt> getValueTypeAnnotations() {
    if (valueTypeAnnotations instanceof ImmutableList) {
      valueTypeAnnotations = new ArrayList<Excerpt>(valueTypeAnnotations);
    }
    return Collections.unmodifiableList(valueTypeAnnotations);
  }

  /**
   * Sets the value to be returned by {@link Metadata#getValueTypeVisibility()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code valueTypeVisibility} is null
   */
  public Metadata.Builder setValueTypeVisibility(Metadata.Visibility valueTypeVisibility) {
    this.valueTypeVisibility = Preconditions.checkNotNull(valueTypeVisibility);
    _unsetProperties.remove(Metadata_Builder.Property.VALUE_TYPE_VISIBILITY);
    return (Metadata.Builder) this;
  }

  /**
   * Returns the value that will be returned by {@link Metadata#getValueTypeVisibility()}.
   *
   * @throws IllegalStateException if the field has not been set
   */
  public Metadata.Visibility getValueTypeVisibility() {
    Preconditions.checkState(
        !_unsetProperties.contains(Metadata_Builder.Property.VALUE_TYPE_VISIBILITY),
        "valueTypeVisibility not set");
    return valueTypeVisibility;
  }

  /**
   * Adds {@code element} to the list to be returned from {@link Metadata#getNestedClasses()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code element} is null
   */
  public Metadata.Builder addNestedClasses(
      Function<Metadata, Excerpt> element) {
    if (this.nestedClasses instanceof ImmutableList) {
      this.nestedClasses =
          new ArrayList<Function<Metadata, Excerpt>>(
              this.nestedClasses);
    }
    this.nestedClasses.add(Preconditions.checkNotNull(element));
    return (Metadata.Builder) this;
  }

  /**
   * Adds each element of {@code elements} to the list to be returned from
   * {@link Metadata#getNestedClasses()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code elements} is null or contains a
   *     null element
   */
  public Metadata.Builder addNestedClasses(
      Function<Metadata, Excerpt>... elements) {
    return addAllNestedClasses(Arrays.asList(elements));
  }

  /**
   * Adds each element of {@code elements} to the list to be returned from
   * {@link Metadata#getNestedClasses()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code elements} is null or contains a
   *     null element
   */
  public Metadata.Builder addAllNestedClasses(
      Iterable<? extends Function<Metadata, Excerpt>> elements) {
    if (elements instanceof Collection) {
      int elementsSize = ((Collection<?>) elements).size();
      if (elementsSize != 0) {
        if (nestedClasses instanceof ImmutableList) {
          nestedClasses =
              new ArrayList<Function<Metadata, Excerpt>>(
                  nestedClasses);
        }
        ((ArrayList<?>) nestedClasses).ensureCapacity(nestedClasses.size() + elementsSize);
      }
    }
    for (Function<Metadata, Excerpt> element : elements) {
      addNestedClasses(element);
    }
    return (Metadata.Builder) this;
  }

  /**
   * Clears the list to be returned from {@link Metadata#getNestedClasses()}.
   *
   * @return this {@code Builder} object
   */
  public Metadata.Builder clearNestedClasses() {
    if (nestedClasses instanceof ImmutableList) {
      nestedClasses = ImmutableList.of();
    } else {
      nestedClasses.clear();
    }
    return (Metadata.Builder) this;
  }

  /**
   * Returns an unmodifiable view of the list that will be returned by
   * {@link Metadata#getNestedClasses()}.
   * Changes to this builder will be reflected in the view.
   */
  public List<Function<Metadata, Excerpt>> getNestedClasses() {
    if (nestedClasses instanceof ImmutableList) {
      nestedClasses =
          new ArrayList<Function<Metadata, Excerpt>>(
              nestedClasses);
    }
    return Collections.unmodifiableList(nestedClasses);
  }

  /**
   * Sets all property values using the given {@code Metadata} as a template.
   */
  public Metadata.Builder mergeFrom(Metadata value) {
    Metadata_Builder _defaults = new Metadata.Builder();
    if (_defaults._unsetProperties.contains(Metadata_Builder.Property.TYPE)
        || !value.getType().equals(_defaults.getType())) {
      setType(value.getType());
    }
    if (_defaults._unsetProperties.contains(Metadata_Builder.Property.TYPE_GEN)
        || !value.getTypeGen().equals(_defaults.getTypeGen())) {
      setTypeGen(value.getTypeGen());
    }
    if (_defaults._unsetProperties.contains(Metadata_Builder.Property.BUILD_GEN)
        || !value.getBuildGen().equals(_defaults.getBuildGen())) {
      setBuildGen(value.getBuildGen());
    }
    if (_defaults._unsetProperties.contains(Metadata_Builder.Property.INTERFACE_TYPE)
        || value.isInterfaceType() != _defaults.isInterfaceType()) {
      setInterfaceType(value.isInterfaceType());
    }
    if (value.getOptionalBuilder().isPresent()) {
      setOptionalBuilder(value.getOptionalBuilder().get());
    }
    if (value.getOptionalABuilder().isPresent()) {
      setOptionalABuilder(value.getOptionalABuilder().get());
    }
    if (value.getOptionalABuilderAncestor().isPresent()) {
      setOptionalABuilderAncestor(value.getOptionalABuilderAncestor().get());
    }
    if (value.getOptionalABuilderExtension().isPresent()) {
      setOptionalABuilderExtension(value.getOptionalABuilderExtension().get());
    }
    if (value.getBuilderFactory().isPresent()) {
      setBuilderFactory(value.getBuilderFactory().get());
    }
    if (_defaults._unsetProperties.contains(Metadata_Builder.Property.GENERATED_A_BUILDER)
        || !value.getGeneratedABuilder().equals(_defaults.getGeneratedABuilder())) {
      setGeneratedABuilder(value.getGeneratedABuilder());
    }
    if (_defaults._unsetProperties.contains(
            Metadata_Builder.Property.GENERATED_A_BUILDER_PARAMETRIZED)
        || !value
            .getGeneratedABuilderParametrized()
            .equals(_defaults.getGeneratedABuilderParametrized())) {
      setGeneratedABuilderParametrized(value.getGeneratedABuilderParametrized());
    }
    if (_defaults._unsetProperties.contains(
            Metadata_Builder.Property.GENERATED_A_BUILDER_PARAMETRIZED_SPEC)
        || !value
            .getGeneratedABuilderParametrizedSpec()
            .equals(_defaults.getGeneratedABuilderParametrizedSpec())) {
      setGeneratedABuilderParametrizedSpec(value.getGeneratedABuilderParametrizedSpec());
    }
    if (_defaults._unsetProperties.contains(Metadata_Builder.Property.GENERATED_BUILDER)
        || !value.getGeneratedBuilder().equals(_defaults.getGeneratedBuilder())) {
      setGeneratedBuilder(value.getGeneratedBuilder());
    }
    if (_defaults._unsetProperties.contains(Metadata_Builder.Property.VALUE_TYPE)
        || !value.getValueType().equals(_defaults.getValueType())) {
      setValueType(value.getValueType());
    }
    if (_defaults._unsetProperties.contains(Metadata_Builder.Property.PARTIAL_TYPE)
        || !value.getPartialType().equals(_defaults.getPartialType())) {
      setPartialType(value.getPartialType());
    }
    if (value instanceof Metadata_Builder.Value
        && visibleNestedTypes == ImmutableSet.<QualifiedName>of()) {
      visibleNestedTypes = value.getVisibleNestedTypes();
    } else {
      addAllVisibleNestedTypes(value.getVisibleNestedTypes());
    }
    if (_defaults._unsetProperties.contains(Metadata_Builder.Property.PROPERTY_ENUM)
        || !value.getPropertyEnum().equals(_defaults.getPropertyEnum())) {
      setPropertyEnum(value.getPropertyEnum());
    }
    if (value instanceof Metadata_Builder.Value
        && properties == ImmutableList.<Metadata.Property>of()) {
      properties = value.getProperties();
    } else {
      addAllProperties(value.getProperties());
    }
    if (value instanceof Metadata_Builder.Value
        && ownProperties == ImmutableList.<Metadata.Property>of()) {
      ownProperties = value.getOwnProperties();
    } else {
      addAllOwnProperties(value.getOwnProperties());
    }
    if (value instanceof Metadata_Builder.Value
        && superBuilderTypes == ImmutableSet.<ParameterizedType>of()) {
      superBuilderTypes = value.getSuperBuilderTypes();
    } else {
      addAllSuperBuilderTypes(value.getSuperBuilderTypes());
    }
    putAllSuperTypeProperties(value.getSuperTypeProperties());
    putAllStandardMethodUnderrides(value.getStandardMethodUnderrides());
    if (_defaults._unsetProperties.contains(Metadata_Builder.Property.BUILDER_SERIALIZABLE)
        || value.isBuilderSerializable() != _defaults.isBuilderSerializable()) {
      setBuilderSerializable(value.isBuilderSerializable());
    }
    if (value instanceof Metadata_Builder.Value
        && generatedBuilderAnnotations == ImmutableList.<Excerpt>of()) {
      generatedBuilderAnnotations = value.getGeneratedBuilderAnnotations();
    } else {
      addAllGeneratedBuilderAnnotations(value.getGeneratedBuilderAnnotations());
    }
    if (value instanceof Metadata_Builder.Value
        && valueTypeAnnotations == ImmutableList.<Excerpt>of()) {
      valueTypeAnnotations = value.getValueTypeAnnotations();
    } else {
      addAllValueTypeAnnotations(value.getValueTypeAnnotations());
    }
    if (_defaults._unsetProperties.contains(Metadata_Builder.Property.VALUE_TYPE_VISIBILITY)
        || !value.getValueTypeVisibility().equals(_defaults.getValueTypeVisibility())) {
      setValueTypeVisibility(value.getValueTypeVisibility());
    }
    if (value instanceof Metadata_Builder.Value
        && nestedClasses
            == ImmutableList.<Function<Metadata, Excerpt>>of()) {
      nestedClasses = value.getNestedClasses();
    } else {
      addAllNestedClasses(value.getNestedClasses());
    }
    return (Metadata.Builder) this;
  }

  /**
   * Copies values from the given {@code Builder}.
   * Does not affect any properties not set on the input.
   */
  public Metadata.Builder mergeFrom(Metadata.Builder template) {
    // Upcast to access private fields; otherwise, oddly, we get an access violation.
    Metadata_Builder base = (Metadata_Builder) template;
    Metadata_Builder _defaults = new Metadata.Builder();
    if (!base._unsetProperties.contains(Metadata_Builder.Property.TYPE)
        && (_defaults._unsetProperties.contains(Metadata_Builder.Property.TYPE)
            || !template.getType().equals(_defaults.getType()))) {
      setType(template.getType());
    }
    if (!base._unsetProperties.contains(Metadata_Builder.Property.TYPE_GEN)
        && (_defaults._unsetProperties.contains(Metadata_Builder.Property.TYPE_GEN)
            || !template.getTypeGen().equals(_defaults.getTypeGen()))) {
      setTypeGen(template.getTypeGen());
    }
    if (!base._unsetProperties.contains(Metadata_Builder.Property.BUILD_GEN)
        && (_defaults._unsetProperties.contains(Metadata_Builder.Property.BUILD_GEN)
            || !template.getBuildGen().equals(_defaults.getBuildGen()))) {
      setBuildGen(template.getBuildGen());
    }
    if (!base._unsetProperties.contains(Metadata_Builder.Property.INTERFACE_TYPE)
        && (_defaults._unsetProperties.contains(Metadata_Builder.Property.INTERFACE_TYPE)
            || template.isInterfaceType() != _defaults.isInterfaceType())) {
      setInterfaceType(template.isInterfaceType());
    }
    if (template.getOptionalBuilder().isPresent()) {
      setOptionalBuilder(template.getOptionalBuilder().get());
    }
    if (template.getOptionalABuilder().isPresent()) {
      setOptionalABuilder(template.getOptionalABuilder().get());
    }
    if (template.getOptionalABuilderAncestor().isPresent()) {
      setOptionalABuilderAncestor(template.getOptionalABuilderAncestor().get());
    }
    if (template.getOptionalABuilderExtension().isPresent()) {
      setOptionalABuilderExtension(template.getOptionalABuilderExtension().get());
    }
    if (template.getBuilderFactory().isPresent()) {
      setBuilderFactory(template.getBuilderFactory().get());
    }
    if (!base._unsetProperties.contains(Metadata_Builder.Property.GENERATED_A_BUILDER)
        && (_defaults._unsetProperties.contains(Metadata_Builder.Property.GENERATED_A_BUILDER)
            || !template.getGeneratedABuilder().equals(_defaults.getGeneratedABuilder()))) {
      setGeneratedABuilder(template.getGeneratedABuilder());
    }
    if (!base._unsetProperties.contains(Metadata_Builder.Property.GENERATED_A_BUILDER_PARAMETRIZED)
        && (_defaults._unsetProperties.contains(
                Metadata_Builder.Property.GENERATED_A_BUILDER_PARAMETRIZED)
            || !template
                .getGeneratedABuilderParametrized()
                .equals(_defaults.getGeneratedABuilderParametrized()))) {
      setGeneratedABuilderParametrized(template.getGeneratedABuilderParametrized());
    }
    if (!base._unsetProperties.contains(
            Metadata_Builder.Property.GENERATED_A_BUILDER_PARAMETRIZED_SPEC)
        && (_defaults._unsetProperties.contains(
                Metadata_Builder.Property.GENERATED_A_BUILDER_PARAMETRIZED_SPEC)
            || !template
                .getGeneratedABuilderParametrizedSpec()
                .equals(_defaults.getGeneratedABuilderParametrizedSpec()))) {
      setGeneratedABuilderParametrizedSpec(template.getGeneratedABuilderParametrizedSpec());
    }
    if (!base._unsetProperties.contains(Metadata_Builder.Property.GENERATED_BUILDER)
        && (_defaults._unsetProperties.contains(Metadata_Builder.Property.GENERATED_BUILDER)
            || !template.getGeneratedBuilder().equals(_defaults.getGeneratedBuilder()))) {
      setGeneratedBuilder(template.getGeneratedBuilder());
    }
    if (!base._unsetProperties.contains(Metadata_Builder.Property.VALUE_TYPE)
        && (_defaults._unsetProperties.contains(Metadata_Builder.Property.VALUE_TYPE)
            || !template.getValueType().equals(_defaults.getValueType()))) {
      setValueType(template.getValueType());
    }
    if (!base._unsetProperties.contains(Metadata_Builder.Property.PARTIAL_TYPE)
        && (_defaults._unsetProperties.contains(Metadata_Builder.Property.PARTIAL_TYPE)
            || !template.getPartialType().equals(_defaults.getPartialType()))) {
      setPartialType(template.getPartialType());
    }
    addAllVisibleNestedTypes(((Metadata_Builder) template).visibleNestedTypes);
    if (!base._unsetProperties.contains(Metadata_Builder.Property.PROPERTY_ENUM)
        && (_defaults._unsetProperties.contains(Metadata_Builder.Property.PROPERTY_ENUM)
            || !template.getPropertyEnum().equals(_defaults.getPropertyEnum()))) {
      setPropertyEnum(template.getPropertyEnum());
    }
    addAllProperties(base.properties);
    addAllOwnProperties(base.ownProperties);
    addAllSuperBuilderTypes(((Metadata_Builder) template).superBuilderTypes);
    putAllSuperTypeProperties(((Metadata_Builder) template).superTypeProperties);
    putAllStandardMethodUnderrides(((Metadata_Builder) template).standardMethodUnderrides);
    if (!base._unsetProperties.contains(Metadata_Builder.Property.BUILDER_SERIALIZABLE)
        && (_defaults._unsetProperties.contains(Metadata_Builder.Property.BUILDER_SERIALIZABLE)
            || template.isBuilderSerializable() != _defaults.isBuilderSerializable())) {
      setBuilderSerializable(template.isBuilderSerializable());
    }
    addAllGeneratedBuilderAnnotations(base.generatedBuilderAnnotations);
    addAllValueTypeAnnotations(base.valueTypeAnnotations);
    if (!base._unsetProperties.contains(Metadata_Builder.Property.VALUE_TYPE_VISIBILITY)
        && (_defaults._unsetProperties.contains(Metadata_Builder.Property.VALUE_TYPE_VISIBILITY)
            || !template.getValueTypeVisibility().equals(_defaults.getValueTypeVisibility()))) {
      setValueTypeVisibility(template.getValueTypeVisibility());
    }
    addAllNestedClasses(base.nestedClasses);
    return (Metadata.Builder) this;
  }

  /**
   * Resets the state of this builder.
   */
  public Metadata.Builder clear() {
    Metadata_Builder _defaults = new Metadata.Builder();
    type = _defaults.type;
    typeGen = _defaults.typeGen;
    buildGen = _defaults.buildGen;
    interfaceType = _defaults.interfaceType;
    optionalBuilder = _defaults.optionalBuilder;
    optionalABuilder = _defaults.optionalABuilder;
    optionalABuilderAncestor = _defaults.optionalABuilderAncestor;
    optionalABuilderExtension = _defaults.optionalABuilderExtension;
    builderFactory = _defaults.builderFactory;
    generatedABuilder = _defaults.generatedABuilder;
    generatedABuilderParametrized = _defaults.generatedABuilderParametrized;
    generatedABuilderParametrizedSpec = _defaults.generatedABuilderParametrizedSpec;
    generatedBuilder = _defaults.generatedBuilder;
    valueType = _defaults.valueType;
    partialType = _defaults.partialType;
    clearVisibleNestedTypes();
    propertyEnum = _defaults.propertyEnum;
    clearProperties();
    clearOwnProperties();
    clearSuperBuilderTypes();
    superTypeProperties.clear();
    standardMethodUnderrides.clear();
    builderSerializable = _defaults.builderSerializable;
    clearGeneratedBuilderAnnotations();
    clearValueTypeAnnotations();
    valueTypeVisibility = _defaults.valueTypeVisibility;
    clearNestedClasses();
    _unsetProperties.clear();
    _unsetProperties.addAll(_defaults._unsetProperties);
    return (Metadata.Builder) this;
  }

  /**
   * Returns a newly-created {@link Metadata} based on the contents of the {@code Builder}.
   *
   * @throws IllegalStateException if any field has not been set
   */
  public Metadata build() {
    Preconditions.checkState(_unsetProperties.isEmpty(), "Not set: %s", _unsetProperties);
    return new Metadata_Builder.Value(this);
  }

  /**
   * Returns a newly-created partial {@link Metadata}
   * based on the contents of the {@code Builder}.
   * State checking will not be performed.
   * Unset properties will throw an {@link UnsupportedOperationException}
   * when accessed via the partial object.
   *
   * <p>Partials should only ever be used in tests.
   */
  @VisibleForTesting()
  public Metadata buildPartial() {
    return new Metadata_Builder.Partial(this);
  }

  private static final class Value extends Metadata {
    private final ParameterizedType type;
    private final String typeGen;
    private final String buildGen;
    private final boolean interfaceType;
    // Store a nullable object instead of an Optional. Escape analysis then
    // allows the JVM to optimize away the Optional objects created by our
    // getter method.
    private final ParameterizedType optionalBuilder;
    // Store a nullable object instead of an Optional. Escape analysis then
    // allows the JVM to optimize away the Optional objects created by our
    // getter method.
    private final ParameterizedType optionalABuilder;
    // Store a nullable object instead of an Optional. Escape analysis then
    // allows the JVM to optimize away the Optional objects created by our
    // getter method.
    private final ParameterizedType optionalABuilderAncestor;
    // Store a nullable object instead of an Optional. Escape analysis then
    // allows the JVM to optimize away the Optional objects created by our
    // getter method.
    private final ParameterizedType optionalABuilderExtension;
    // Store a nullable object instead of an Optional. Escape analysis then
    // allows the JVM to optimize away the Optional objects created by our
    // getter method.
    private final BuilderFactory builderFactory;
    private final ParameterizedType generatedABuilder;
    private final ParameterizedType generatedABuilderParametrized;
    private final ParameterizedType generatedABuilderParametrizedSpec;
    private final ParameterizedType generatedBuilder;
    private final ParameterizedType valueType;
    private final ParameterizedType partialType;
    private final ImmutableSet<QualifiedName> visibleNestedTypes;
    private final ParameterizedType propertyEnum;
    private final ImmutableList<Property> properties;
    private final ImmutableList<Property> ownProperties;
    private final ImmutableSet<ParameterizedType> superBuilderTypes;
    private final ImmutableMap<ParameterizedType, ImmutableList<Property>>
        superTypeProperties;
    private final ImmutableMap<StandardMethod, UnderrideLevel>
        standardMethodUnderrides;
    private final boolean builderSerializable;
    private final ImmutableList<Excerpt> generatedBuilderAnnotations;
    private final ImmutableList<Excerpt> valueTypeAnnotations;
    private final Metadata.Visibility valueTypeVisibility;
    private final ImmutableList<Function<Metadata, Excerpt>>
        nestedClasses;

    private Value(Metadata_Builder builder) {
      this.type = builder.type;
      this.typeGen = builder.typeGen;
      this.buildGen = builder.buildGen;
      this.interfaceType = builder.interfaceType;
      this.optionalBuilder = builder.optionalBuilder;
      this.optionalABuilder = builder.optionalABuilder;
      this.optionalABuilderAncestor = builder.optionalABuilderAncestor;
      this.optionalABuilderExtension = builder.optionalABuilderExtension;
      this.builderFactory = builder.builderFactory;
      this.generatedABuilder = builder.generatedABuilder;
      this.generatedABuilderParametrized = builder.generatedABuilderParametrized;
      this.generatedABuilderParametrizedSpec = builder.generatedABuilderParametrizedSpec;
      this.generatedBuilder = builder.generatedBuilder;
      this.valueType = builder.valueType;
      this.partialType = builder.partialType;
      this.visibleNestedTypes = ImmutableSet.copyOf(builder.visibleNestedTypes);
      this.propertyEnum = builder.propertyEnum;
      this.properties = ImmutableList.copyOf(builder.properties);
      this.ownProperties = ImmutableList.copyOf(builder.ownProperties);
      this.superBuilderTypes = ImmutableSet.copyOf(builder.superBuilderTypes);
      this.superTypeProperties = ImmutableMap.copyOf(builder.superTypeProperties);
      this.standardMethodUnderrides = ImmutableMap.copyOf(builder.standardMethodUnderrides);
      this.builderSerializable = builder.builderSerializable;
      this.generatedBuilderAnnotations = ImmutableList.copyOf(builder.generatedBuilderAnnotations);
      this.valueTypeAnnotations = ImmutableList.copyOf(builder.valueTypeAnnotations);
      this.valueTypeVisibility = builder.valueTypeVisibility;
      this.nestedClasses = ImmutableList.copyOf(builder.nestedClasses);
    }

    @Override
    public ParameterizedType getType() {
      return type;
    }

    @Override
    public String getTypeGen() {
      return typeGen;
    }

    @Override
    public String getBuildGen() {
      return buildGen;
    }

    @Override
    public boolean isInterfaceType() {
      return interfaceType;
    }

    @Override
    public Optional<ParameterizedType> getOptionalBuilder() {
      return Optional.fromNullable(optionalBuilder);
    }

    @Override
    public Optional<ParameterizedType> getOptionalABuilder() {
      return Optional.fromNullable(optionalABuilder);
    }

    @Override
    public Optional<ParameterizedType> getOptionalABuilderAncestor() {
      return Optional.fromNullable(optionalABuilderAncestor);
    }

    @Override
    public Optional<ParameterizedType> getOptionalABuilderExtension() {
      return Optional.fromNullable(optionalABuilderExtension);
    }

    @Override
    public Optional<BuilderFactory> getBuilderFactory() {
      return Optional.fromNullable(builderFactory);
    }

    @Override
    public ParameterizedType getGeneratedABuilder() {
      return generatedABuilder;
    }

    @Override
    public ParameterizedType getGeneratedABuilderParametrized() {
      return generatedABuilderParametrized;
    }

    @Override
    public ParameterizedType getGeneratedABuilderParametrizedSpec() {
      return generatedABuilderParametrizedSpec;
    }

    @Override
    public ParameterizedType getGeneratedBuilder() {
      return generatedBuilder;
    }

    @Override
    public ParameterizedType getValueType() {
      return valueType;
    }

    @Override
    public ParameterizedType getPartialType() {
      return partialType;
    }

    @Override
    public ImmutableSet<QualifiedName> getVisibleNestedTypes() {
      return visibleNestedTypes;
    }

    @Override
    public ParameterizedType getPropertyEnum() {
      return propertyEnum;
    }

    @Override
    public ImmutableList<Property> getProperties() {
      return properties;
    }

    @Override
    public ImmutableList<Property> getOwnProperties() {
      return ownProperties;
    }

    @Override
    public ImmutableSet<ParameterizedType> getSuperBuilderTypes() {
      return superBuilderTypes;
    }

    @Override
    public ImmutableMap<ParameterizedType, ImmutableList<Property>>
        getSuperTypeProperties() {
      return superTypeProperties;
    }

    @Override
    public ImmutableMap<StandardMethod, UnderrideLevel>
        getStandardMethodUnderrides() {
      return standardMethodUnderrides;
    }

    @Override
    public boolean isBuilderSerializable() {
      return builderSerializable;
    }

    @Override
    public ImmutableList<Excerpt> getGeneratedBuilderAnnotations() {
      return generatedBuilderAnnotations;
    }

    @Override
    public ImmutableList<Excerpt> getValueTypeAnnotations() {
      return valueTypeAnnotations;
    }

    @Override
    public Metadata.Visibility getValueTypeVisibility() {
      return valueTypeVisibility;
    }

    @Override
    public ImmutableList<Function<Metadata, Excerpt>>
        getNestedClasses() {
      return nestedClasses;
    }

    @Override
    public boolean equals(Object obj) {
      if (!(obj instanceof Metadata_Builder.Value)) {
        return false;
      }
      Metadata_Builder.Value other = (Metadata_Builder.Value) obj;
      if (!type.equals(other.type)) {
        return false;
      }
      if (!typeGen.equals(other.typeGen)) {
        return false;
      }
      if (!buildGen.equals(other.buildGen)) {
        return false;
      }
      if (interfaceType != other.interfaceType) {
        return false;
      }
      if (optionalBuilder != other.optionalBuilder
          && (optionalBuilder == null || !optionalBuilder.equals(other.optionalBuilder))) {
        return false;
      }
      if (optionalABuilder != other.optionalABuilder
          && (optionalABuilder == null || !optionalABuilder.equals(other.optionalABuilder))) {
        return false;
      }
      if (optionalABuilderAncestor != other.optionalABuilderAncestor
          && (optionalABuilderAncestor == null
              || !optionalABuilderAncestor.equals(other.optionalABuilderAncestor))) {
        return false;
      }
      if (optionalABuilderExtension != other.optionalABuilderExtension
          && (optionalABuilderExtension == null
              || !optionalABuilderExtension.equals(other.optionalABuilderExtension))) {
        return false;
      }
      if (builderFactory != other.builderFactory
          && (builderFactory == null || !builderFactory.equals(other.builderFactory))) {
        return false;
      }
      if (!generatedABuilder.equals(other.generatedABuilder)) {
        return false;
      }
      if (!generatedABuilderParametrized.equals(other.generatedABuilderParametrized)) {
        return false;
      }
      if (!generatedABuilderParametrizedSpec.equals(other.generatedABuilderParametrizedSpec)) {
        return false;
      }
      if (!generatedBuilder.equals(other.generatedBuilder)) {
        return false;
      }
      if (!valueType.equals(other.valueType)) {
        return false;
      }
      if (!partialType.equals(other.partialType)) {
        return false;
      }
      if (!visibleNestedTypes.equals(other.visibleNestedTypes)) {
        return false;
      }
      if (!propertyEnum.equals(other.propertyEnum)) {
        return false;
      }
      if (!properties.equals(other.properties)) {
        return false;
      }
      if (!ownProperties.equals(other.ownProperties)) {
        return false;
      }
      if (!superBuilderTypes.equals(other.superBuilderTypes)) {
        return false;
      }
      if (!superTypeProperties.equals(other.superTypeProperties)) {
        return false;
      }
      if (!standardMethodUnderrides.equals(other.standardMethodUnderrides)) {
        return false;
      }
      if (builderSerializable != other.builderSerializable) {
        return false;
      }
      if (!generatedBuilderAnnotations.equals(other.generatedBuilderAnnotations)) {
        return false;
      }
      if (!valueTypeAnnotations.equals(other.valueTypeAnnotations)) {
        return false;
      }
      if (!valueTypeVisibility.equals(other.valueTypeVisibility)) {
        return false;
      }
      if (!nestedClasses.equals(other.nestedClasses)) {
        return false;
      }
      return true;
    }

    @Override
    public int hashCode() {
      return Arrays.hashCode(
          new Object[] {
            type,
            typeGen,
            buildGen,
            interfaceType,
            optionalBuilder,
            optionalABuilder,
            optionalABuilderAncestor,
            optionalABuilderExtension,
            builderFactory,
            generatedABuilder,
            generatedABuilderParametrized,
            generatedABuilderParametrizedSpec,
            generatedBuilder,
            valueType,
            partialType,
            visibleNestedTypes,
            propertyEnum,
            properties,
            ownProperties,
            superBuilderTypes,
            superTypeProperties,
            standardMethodUnderrides,
            builderSerializable,
            generatedBuilderAnnotations,
            valueTypeAnnotations,
            valueTypeVisibility,
            nestedClasses
          });
    }

    @Override
    public String toString() {
      return "Metadata{"
          + COMMA_JOINER.join(
              "type=" + type,
              "typeGen=" + typeGen,
              "buildGen=" + buildGen,
              "interfaceType=" + interfaceType,
              (optionalBuilder != null ? "optionalBuilder=" + optionalBuilder : null),
              (optionalABuilder != null ? "optionalABuilder=" + optionalABuilder : null),
              (optionalABuilderAncestor != null
                  ? "optionalABuilderAncestor=" + optionalABuilderAncestor
                  : null),
              (optionalABuilderExtension != null
                  ? "optionalABuilderExtension=" + optionalABuilderExtension
                  : null),
              (builderFactory != null ? "builderFactory=" + builderFactory : null),
              "generatedABuilder=" + generatedABuilder,
              "generatedABuilderParametrized=" + generatedABuilderParametrized,
              "generatedABuilderParametrizedSpec=" + generatedABuilderParametrizedSpec,
              "generatedBuilder=" + generatedBuilder,
              "valueType=" + valueType,
              "partialType=" + partialType,
              "visibleNestedTypes=" + visibleNestedTypes,
              "propertyEnum=" + propertyEnum,
              "properties=" + properties,
              "ownProperties=" + ownProperties,
              "superBuilderTypes=" + superBuilderTypes,
              "superTypeProperties=" + superTypeProperties,
              "standardMethodUnderrides=" + standardMethodUnderrides,
              "builderSerializable=" + builderSerializable,
              "generatedBuilderAnnotations=" + generatedBuilderAnnotations,
              "valueTypeAnnotations=" + valueTypeAnnotations,
              "valueTypeVisibility=" + valueTypeVisibility,
              "nestedClasses=" + nestedClasses)
          + "}";
    }
  }

  private static final class Partial extends Metadata {
    private final ParameterizedType type;
    private final String typeGen;
    private final String buildGen;
    private final boolean interfaceType;
    // Store a nullable object instead of an Optional. Escape analysis then
    // allows the JVM to optimize away the Optional objects created by our
    // getter method.
    private final ParameterizedType optionalBuilder;
    // Store a nullable object instead of an Optional. Escape analysis then
    // allows the JVM to optimize away the Optional objects created by our
    // getter method.
    private final ParameterizedType optionalABuilder;
    // Store a nullable object instead of an Optional. Escape analysis then
    // allows the JVM to optimize away the Optional objects created by our
    // getter method.
    private final ParameterizedType optionalABuilderAncestor;
    // Store a nullable object instead of an Optional. Escape analysis then
    // allows the JVM to optimize away the Optional objects created by our
    // getter method.
    private final ParameterizedType optionalABuilderExtension;
    // Store a nullable object instead of an Optional. Escape analysis then
    // allows the JVM to optimize away the Optional objects created by our
    // getter method.
    private final BuilderFactory builderFactory;
    private final ParameterizedType generatedABuilder;
    private final ParameterizedType generatedABuilderParametrized;
    private final ParameterizedType generatedABuilderParametrizedSpec;
    private final ParameterizedType generatedBuilder;
    private final ParameterizedType valueType;
    private final ParameterizedType partialType;
    private final ImmutableSet<QualifiedName> visibleNestedTypes;
    private final ParameterizedType propertyEnum;
    private final ImmutableList<Property> properties;
    private final ImmutableList<Property> ownProperties;
    private final ImmutableSet<ParameterizedType> superBuilderTypes;
    private final ImmutableMap<ParameterizedType, ImmutableList<Property>>
        superTypeProperties;
    private final ImmutableMap<StandardMethod, UnderrideLevel>
        standardMethodUnderrides;
    private final boolean builderSerializable;
    private final ImmutableList<Excerpt> generatedBuilderAnnotations;
    private final ImmutableList<Excerpt> valueTypeAnnotations;
    private final Metadata.Visibility valueTypeVisibility;
    private final ImmutableList<Function<Metadata, Excerpt>>
        nestedClasses;
    private final EnumSet<Metadata_Builder.Property> _unsetProperties;

    Partial(Metadata_Builder builder) {
      this.type = builder.type;
      this.typeGen = builder.typeGen;
      this.buildGen = builder.buildGen;
      this.interfaceType = builder.interfaceType;
      this.optionalBuilder = builder.optionalBuilder;
      this.optionalABuilder = builder.optionalABuilder;
      this.optionalABuilderAncestor = builder.optionalABuilderAncestor;
      this.optionalABuilderExtension = builder.optionalABuilderExtension;
      this.builderFactory = builder.builderFactory;
      this.generatedABuilder = builder.generatedABuilder;
      this.generatedABuilderParametrized = builder.generatedABuilderParametrized;
      this.generatedABuilderParametrizedSpec = builder.generatedABuilderParametrizedSpec;
      this.generatedBuilder = builder.generatedBuilder;
      this.valueType = builder.valueType;
      this.partialType = builder.partialType;
      this.visibleNestedTypes = ImmutableSet.copyOf(builder.visibleNestedTypes);
      this.propertyEnum = builder.propertyEnum;
      this.properties = ImmutableList.copyOf(builder.properties);
      this.ownProperties = ImmutableList.copyOf(builder.ownProperties);
      this.superBuilderTypes = ImmutableSet.copyOf(builder.superBuilderTypes);
      this.superTypeProperties = ImmutableMap.copyOf(builder.superTypeProperties);
      this.standardMethodUnderrides = ImmutableMap.copyOf(builder.standardMethodUnderrides);
      this.builderSerializable = builder.builderSerializable;
      this.generatedBuilderAnnotations = ImmutableList.copyOf(builder.generatedBuilderAnnotations);
      this.valueTypeAnnotations = ImmutableList.copyOf(builder.valueTypeAnnotations);
      this.valueTypeVisibility = builder.valueTypeVisibility;
      this.nestedClasses = ImmutableList.copyOf(builder.nestedClasses);
      this._unsetProperties = builder._unsetProperties.clone();
    }

    @Override
    public ParameterizedType getType() {
      if (_unsetProperties.contains(Metadata_Builder.Property.TYPE)) {
        throw new UnsupportedOperationException("type not set");
      }
      return type;
    }

    @Override
    public String getTypeGen() {
      if (_unsetProperties.contains(Metadata_Builder.Property.TYPE_GEN)) {
        throw new UnsupportedOperationException("typeGen not set");
      }
      return typeGen;
    }

    @Override
    public String getBuildGen() {
      if (_unsetProperties.contains(Metadata_Builder.Property.BUILD_GEN)) {
        throw new UnsupportedOperationException("buildGen not set");
      }
      return buildGen;
    }

    @Override
    public boolean isInterfaceType() {
      if (_unsetProperties.contains(Metadata_Builder.Property.INTERFACE_TYPE)) {
        throw new UnsupportedOperationException("interfaceType not set");
      }
      return interfaceType;
    }

    @Override
    public Optional<ParameterizedType> getOptionalBuilder() {
      return Optional.fromNullable(optionalBuilder);
    }

    @Override
    public Optional<ParameterizedType> getOptionalABuilder() {
      return Optional.fromNullable(optionalABuilder);
    }

    @Override
    public Optional<ParameterizedType> getOptionalABuilderAncestor() {
      return Optional.fromNullable(optionalABuilderAncestor);
    }

    @Override
    public Optional<ParameterizedType> getOptionalABuilderExtension() {
      return Optional.fromNullable(optionalABuilderExtension);
    }

    @Override
    public Optional<BuilderFactory> getBuilderFactory() {
      return Optional.fromNullable(builderFactory);
    }

    @Override
    public ParameterizedType getGeneratedABuilder() {
      if (_unsetProperties.contains(Metadata_Builder.Property.GENERATED_A_BUILDER)) {
        throw new UnsupportedOperationException("generatedABuilder not set");
      }
      return generatedABuilder;
    }

    @Override
    public ParameterizedType getGeneratedABuilderParametrized() {
      if (_unsetProperties.contains(Metadata_Builder.Property.GENERATED_A_BUILDER_PARAMETRIZED)) {
        throw new UnsupportedOperationException("generatedABuilderParametrized not set");
      }
      return generatedABuilderParametrized;
    }

    @Override
    public ParameterizedType getGeneratedABuilderParametrizedSpec() {
      if (_unsetProperties.contains(
          Metadata_Builder.Property.GENERATED_A_BUILDER_PARAMETRIZED_SPEC)) {
        throw new UnsupportedOperationException("generatedABuilderParametrizedSpec not set");
      }
      return generatedABuilderParametrizedSpec;
    }

    @Override
    public ParameterizedType getGeneratedBuilder() {
      if (_unsetProperties.contains(Metadata_Builder.Property.GENERATED_BUILDER)) {
        throw new UnsupportedOperationException("generatedBuilder not set");
      }
      return generatedBuilder;
    }

    @Override
    public ParameterizedType getValueType() {
      if (_unsetProperties.contains(Metadata_Builder.Property.VALUE_TYPE)) {
        throw new UnsupportedOperationException("valueType not set");
      }
      return valueType;
    }

    @Override
    public ParameterizedType getPartialType() {
      if (_unsetProperties.contains(Metadata_Builder.Property.PARTIAL_TYPE)) {
        throw new UnsupportedOperationException("partialType not set");
      }
      return partialType;
    }

    @Override
    public ImmutableSet<QualifiedName> getVisibleNestedTypes() {
      return visibleNestedTypes;
    }

    @Override
    public ParameterizedType getPropertyEnum() {
      if (_unsetProperties.contains(Metadata_Builder.Property.PROPERTY_ENUM)) {
        throw new UnsupportedOperationException("propertyEnum not set");
      }
      return propertyEnum;
    }

    @Override
    public ImmutableList<Property> getProperties() {
      return properties;
    }

    @Override
    public ImmutableList<Property> getOwnProperties() {
      return ownProperties;
    }

    @Override
    public ImmutableSet<ParameterizedType> getSuperBuilderTypes() {
      return superBuilderTypes;
    }

    @Override
    public ImmutableMap<ParameterizedType, ImmutableList<Property>>
        getSuperTypeProperties() {
      return superTypeProperties;
    }

    @Override
    public ImmutableMap<StandardMethod, UnderrideLevel>
        getStandardMethodUnderrides() {
      return standardMethodUnderrides;
    }

    @Override
    public boolean isBuilderSerializable() {
      if (_unsetProperties.contains(Metadata_Builder.Property.BUILDER_SERIALIZABLE)) {
        throw new UnsupportedOperationException("builderSerializable not set");
      }
      return builderSerializable;
    }

    @Override
    public ImmutableList<Excerpt> getGeneratedBuilderAnnotations() {
      return generatedBuilderAnnotations;
    }

    @Override
    public ImmutableList<Excerpt> getValueTypeAnnotations() {
      return valueTypeAnnotations;
    }

    @Override
    public Metadata.Visibility getValueTypeVisibility() {
      if (_unsetProperties.contains(Metadata_Builder.Property.VALUE_TYPE_VISIBILITY)) {
        throw new UnsupportedOperationException("valueTypeVisibility not set");
      }
      return valueTypeVisibility;
    }

    @Override
    public ImmutableList<Function<Metadata, Excerpt>>
        getNestedClasses() {
      return nestedClasses;
    }

    @Override
    public boolean equals(Object obj) {
      if (!(obj instanceof Metadata_Builder.Partial)) {
        return false;
      }
      Metadata_Builder.Partial other = (Metadata_Builder.Partial) obj;
      if (type != other.type && (type == null || !type.equals(other.type))) {
        return false;
      }
      if (typeGen != other.typeGen && (typeGen == null || !typeGen.equals(other.typeGen))) {
        return false;
      }
      if (buildGen != other.buildGen && (buildGen == null || !buildGen.equals(other.buildGen))) {
        return false;
      }
      if (interfaceType != other.interfaceType) {
        return false;
      }
      if (optionalBuilder != other.optionalBuilder
          && (optionalBuilder == null || !optionalBuilder.equals(other.optionalBuilder))) {
        return false;
      }
      if (optionalABuilder != other.optionalABuilder
          && (optionalABuilder == null || !optionalABuilder.equals(other.optionalABuilder))) {
        return false;
      }
      if (optionalABuilderAncestor != other.optionalABuilderAncestor
          && (optionalABuilderAncestor == null
              || !optionalABuilderAncestor.equals(other.optionalABuilderAncestor))) {
        return false;
      }
      if (optionalABuilderExtension != other.optionalABuilderExtension
          && (optionalABuilderExtension == null
              || !optionalABuilderExtension.equals(other.optionalABuilderExtension))) {
        return false;
      }
      if (builderFactory != other.builderFactory
          && (builderFactory == null || !builderFactory.equals(other.builderFactory))) {
        return false;
      }
      if (generatedABuilder != other.generatedABuilder
          && (generatedABuilder == null || !generatedABuilder.equals(other.generatedABuilder))) {
        return false;
      }
      if (generatedABuilderParametrized != other.generatedABuilderParametrized
          && (generatedABuilderParametrized == null
              || !generatedABuilderParametrized.equals(other.generatedABuilderParametrized))) {
        return false;
      }
      if (generatedABuilderParametrizedSpec != other.generatedABuilderParametrizedSpec
          && (generatedABuilderParametrizedSpec == null
              || !generatedABuilderParametrizedSpec.equals(
                  other.generatedABuilderParametrizedSpec))) {
        return false;
      }
      if (generatedBuilder != other.generatedBuilder
          && (generatedBuilder == null || !generatedBuilder.equals(other.generatedBuilder))) {
        return false;
      }
      if (valueType != other.valueType
          && (valueType == null || !valueType.equals(other.valueType))) {
        return false;
      }
      if (partialType != other.partialType
          && (partialType == null || !partialType.equals(other.partialType))) {
        return false;
      }
      if (!visibleNestedTypes.equals(other.visibleNestedTypes)) {
        return false;
      }
      if (propertyEnum != other.propertyEnum
          && (propertyEnum == null || !propertyEnum.equals(other.propertyEnum))) {
        return false;
      }
      if (!properties.equals(other.properties)) {
        return false;
      }
      if (!ownProperties.equals(other.ownProperties)) {
        return false;
      }
      if (!superBuilderTypes.equals(other.superBuilderTypes)) {
        return false;
      }
      if (!superTypeProperties.equals(other.superTypeProperties)) {
        return false;
      }
      if (!standardMethodUnderrides.equals(other.standardMethodUnderrides)) {
        return false;
      }
      if (builderSerializable != other.builderSerializable) {
        return false;
      }
      if (!generatedBuilderAnnotations.equals(other.generatedBuilderAnnotations)) {
        return false;
      }
      if (!valueTypeAnnotations.equals(other.valueTypeAnnotations)) {
        return false;
      }
      if (valueTypeVisibility != other.valueTypeVisibility
          && (valueTypeVisibility == null
              || !valueTypeVisibility.equals(other.valueTypeVisibility))) {
        return false;
      }
      if (!nestedClasses.equals(other.nestedClasses)) {
        return false;
      }
      return _unsetProperties.equals(other._unsetProperties);
    }

    @Override
    public int hashCode() {
      return Arrays.hashCode(
          new Object[] {
            type,
            typeGen,
            buildGen,
            interfaceType,
            optionalBuilder,
            optionalABuilder,
            optionalABuilderAncestor,
            optionalABuilderExtension,
            builderFactory,
            generatedABuilder,
            generatedABuilderParametrized,
            generatedABuilderParametrizedSpec,
            generatedBuilder,
            valueType,
            partialType,
            visibleNestedTypes,
            propertyEnum,
            properties,
            ownProperties,
            superBuilderTypes,
            superTypeProperties,
            standardMethodUnderrides,
            builderSerializable,
            generatedBuilderAnnotations,
            valueTypeAnnotations,
            valueTypeVisibility,
            nestedClasses,
            _unsetProperties
          });
    }

    @Override
    public String toString() {
      return "partial Metadata{"
          + COMMA_JOINER.join(
              (!_unsetProperties.contains(Metadata_Builder.Property.TYPE) ? "type=" + type : null),
              (!_unsetProperties.contains(Metadata_Builder.Property.TYPE_GEN)
                  ? "typeGen=" + typeGen
                  : null),
              (!_unsetProperties.contains(Metadata_Builder.Property.BUILD_GEN)
                  ? "buildGen=" + buildGen
                  : null),
              (!_unsetProperties.contains(Metadata_Builder.Property.INTERFACE_TYPE)
                  ? "interfaceType=" + interfaceType
                  : null),
              (optionalBuilder != null ? "optionalBuilder=" + optionalBuilder : null),
              (optionalABuilder != null ? "optionalABuilder=" + optionalABuilder : null),
              (optionalABuilderAncestor != null
                  ? "optionalABuilderAncestor=" + optionalABuilderAncestor
                  : null),
              (optionalABuilderExtension != null
                  ? "optionalABuilderExtension=" + optionalABuilderExtension
                  : null),
              (builderFactory != null ? "builderFactory=" + builderFactory : null),
              (!_unsetProperties.contains(Metadata_Builder.Property.GENERATED_A_BUILDER)
                  ? "generatedABuilder=" + generatedABuilder
                  : null),
              (!_unsetProperties.contains(
                      Metadata_Builder.Property.GENERATED_A_BUILDER_PARAMETRIZED)
                  ? "generatedABuilderParametrized=" + generatedABuilderParametrized
                  : null),
              (!_unsetProperties.contains(
                      Metadata_Builder.Property.GENERATED_A_BUILDER_PARAMETRIZED_SPEC)
                  ? "generatedABuilderParametrizedSpec=" + generatedABuilderParametrizedSpec
                  : null),
              (!_unsetProperties.contains(Metadata_Builder.Property.GENERATED_BUILDER)
                  ? "generatedBuilder=" + generatedBuilder
                  : null),
              (!_unsetProperties.contains(Metadata_Builder.Property.VALUE_TYPE)
                  ? "valueType=" + valueType
                  : null),
              (!_unsetProperties.contains(Metadata_Builder.Property.PARTIAL_TYPE)
                  ? "partialType=" + partialType
                  : null),
              "visibleNestedTypes=" + visibleNestedTypes,
              (!_unsetProperties.contains(Metadata_Builder.Property.PROPERTY_ENUM)
                  ? "propertyEnum=" + propertyEnum
                  : null),
              "properties=" + properties,
              "ownProperties=" + ownProperties,
              "superBuilderTypes=" + superBuilderTypes,
              "superTypeProperties=" + superTypeProperties,
              "standardMethodUnderrides=" + standardMethodUnderrides,
              (!_unsetProperties.contains(Metadata_Builder.Property.BUILDER_SERIALIZABLE)
                  ? "builderSerializable=" + builderSerializable
                  : null),
              "generatedBuilderAnnotations=" + generatedBuilderAnnotations,
              "valueTypeAnnotations=" + valueTypeAnnotations,
              (!_unsetProperties.contains(Metadata_Builder.Property.VALUE_TYPE_VISIBILITY)
                  ? "valueTypeVisibility=" + valueTypeVisibility
                  : null),
              "nestedClasses=" + nestedClasses)
          + "}";
    }
  }
}
